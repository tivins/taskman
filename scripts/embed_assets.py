#!/usr/bin/env python3
"""
Generate web_assets.generated.h from style.css and multiple JS files.
Assets are embedded as C++ raw string literals in the binary.
"""
import argparse
import os
import sys


DELIM = "embed"  # Raw string delimiter; must not appear as )embed" in CSS/JS

# MSVC limits a single string literal to ~16380 chars (C2026). Split into chunks.
CHUNK_SIZE = 16000


def sanitize_name(path):
    """Convert file path to a valid C++ identifier.
    Example: 'filters.js' -> 'FILTERS_JS', 'pagination.js' -> 'PAGINATION_JS'
    """
    name = os.path.basename(path)
    # Replace dots and dashes with underscores
    name = name.replace(".", "_").replace("-", "_")
    return name.upper()


def main():
    ap = argparse.ArgumentParser(description="Embed style.css and JS files into a C++ header")
    ap.add_argument("--css", required=True, help="Path to style.css")
    ap.add_argument("--js", action="append", required=True, help="Path to a JS file (can be used multiple times)")
    ap.add_argument("-o", "--output", required=True, help="Output header path")
    args = ap.parse_args()

    try:
        with open(args.css, "r", encoding="utf-8") as f:
            css = f.read()
    except OSError as e:
        sys.stderr.write(f"embed_assets: cannot read {args.css}: {e}\n")
        sys.exit(1)

    js_files = {}
    for js_path in args.js:
        try:
            with open(js_path, "r", encoding="utf-8") as f:
                js_content = f.read()
            var_name = sanitize_name(js_path)
            js_files[var_name] = js_content
        except OSError as e:
            sys.stderr.write(f"embed_assets: cannot read {js_path}: {e}\n")
            sys.exit(1)

    # Check for delimiter conflicts
    if f"){DELIM}\"" in css:
        sys.stderr.write(f"embed_assets: CSS must not contain ){DELIM}\" (would break raw string)\n")
        sys.exit(1)
    for var_name, js_content in js_files.items():
        if f"){DELIM}\"" in js_content:
            sys.stderr.write(f"embed_assets: JS file {var_name} must not contain ){DELIM}\" (would break raw string)\n")
            sys.exit(1)

    def emit_literal(var_name: str, content: str) -> str:
        if len(content) <= CHUNK_SIZE:
            return f'const char {var_name}[] = R"{DELIM}(\n{content}){DELIM}";'
        parts = []
        for i in range(0, len(content), CHUNK_SIZE):
            chunk = content[i : i + CHUNK_SIZE]
            parts.append(f'R"{DELIM}({chunk}){DELIM}"')
        return f'const char {var_name}[] = ' + "\n    ".join(parts) + ";"

    # Generate header content (keep leading \n as in original single literal)
    declarations = []
    declarations.append(emit_literal("STYLE_CSS", "\n" + css))
    for var_name, js_content in js_files.items():
        declarations.append(emit_literal(var_name, "\n" + js_content))

    out = f'''/** Generated by embed_assets.py from style.css and JS files. Do not edit. */
#pragma once

namespace {{

{chr(10).join(declarations)}

}} // namespace
'''

    try:
        with open(args.output, "w", encoding="utf-8", newline="\n") as f:
            f.write(out)
    except OSError as e:
        sys.stderr.write(f"embed_assets: cannot write {args.output}: {e}\n")
        sys.exit(1)


if __name__ == "__main__":
    main()
