/** Generated by embed_assets.py from style.css and JS files. Do not edit. */
#pragma once

namespace {

const char STYLE_CSS[] = R"embed(

/* --- Dark theme (default): pastel, low contrast --- */
:root {
    --bg: #232830;
    --card: #2a303c;
    --border: #3d4553;
    --text: #9fa7b3;
    --muted: #8b92a0;
    --muted-2: #7a8290;
    --to-do: #9ca3b0;
    --in-progress: #7db8e0;
    --done: #7dbe9a;
    --blocked: #c99494;
    --reached: #7dbe9a;
    --primary: #89b4e0;
    --overlay: rgba(0, 0, 0, 0.45);
    --header-subtle: #252b34;
    --hover-bg: #363d4a;
    --badge-to-do-bg: #3d4553;
    --badge-in-progress-bg: rgba(125, 184, 224, 0.18);
    --badge-done-bg: rgba(125, 190, 154, 0.18);
    --shadow: 0 0 16px rgba(0, 0, 0, 0.25);
    --shadow-modal: 0 24px 40px -8px rgba(0, 0, 0, 0.4);
    --focus-ring: rgba(137, 180, 224, 0.25);
    --error: #c98a8a;
}

/* Light theme (opt-in via class on html/body) */
.theme-light {
    --bg: #f5f6f8;
    --card: #ffffff;
    --border: #e0e4e9;
    --text: #2d333b;
    --muted: #6b7280;
    --muted-2: #8b9199;
    --to-do: #6b7280;
    --in-progress: #0ea5e9;
    --done: #059669;
    --blocked: #dc2626;
    --reached: #059669;
    --primary: #2563eb;
    --overlay: rgba(15, 23, 42, 0.45);
    --header-subtle: #f1f3f5;
    --hover-bg: #e8eaed;
    --badge-to-do-bg: #e2e8f0;
    --badge-in-progress-bg: #e0f2fe;
    --badge-done-bg: #d1fae5;
    --shadow: 0 0 10px rgba(0, 0, 0, 0.08);
    --shadow-modal: 0 20px 25px -5px rgba(0,0,0,0.1), 0 8px 10px -6px rgba(0,0,0,0.1);
    --focus-ring: rgba(37, 99, 235, 0.2);
    --error: #c00;
}
* { 
    box-sizing: border-box; 
}
body {
    font-family: "IBM Plex Sans", system-ui, sans-serif;
    font-size: 15px;
    line-height: 1.5;
    margin: 0;
    background: var(--bg);
    color: var(--text);
}

h1 { 
    margin: 0 0 1rem 0; 
    border-bottom:1px solid var(--border);
    font-weight: 400;
    padding: 0 0.75rem;
}
.task- {
    color: var(--primary);
}
.-man {
    color: var(--muted);
}


.box {
    margin: 1em auto; 
    max-width: 1024px;   
    box-shadow: var(--shadow);
    border-radius: 5px;
    padding: 1em;
    background: var(--card);
}

ul { list-style: none; padding: 0; }
li { padding: 0.25em 0; border-bottom: 1px solid var(--border); }
li a { color: var(--primary); text-decoration: none; }
li a:hover { text-decoration: underline; }
.task-detail { /*max-width: 40em; */ margin-top: 1em; }
.task-detail h2 { margin: 0.5em 0 0.25em; font-size: 1.25rem; }
.task-detail h3 { margin: 1em 0 0.35em; font-size: 1rem; }
.task-description { margin: 0.5em 0; white-space: pre-wrap; }
.task-meta { margin: 0.75em 0; border-collapse: collapse;  width: 100%; }
.task-meta td { padding: 0.2em 1em 0.2em ; vertical-align: top; border-bottom: 1px solid var(--border); }
.task-meta .task-meta-label { font-weight: 600; padding-right: 1em; white-space: nowrap; }

.task-meta .row-title { font-size: 150%; }
.task-meta .row-description { font-size:110%; padding-top: 1rem;padding-bottom: 1rem; }

.task-notes-history {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    margin: 0.5rem 0;
}
.task-note-card {
    padding: 0.75rem 1rem;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    border-left: 3px solid var(--primary);
}
.task-note-meta {
    font-size: 0.8125rem;
    margin-bottom: 0.35rem;
}
.task-note-content {
    white-space: pre-wrap;
    font-size: 0.9375rem;
}

.monospace { font-family: monospace; }

.muted { color: var(--muted); }
.error { color: var(--error); }
.blocked { color: var(--blocked); }
/*.blocked:before { content: "× "; } /* ☒ */
.done { color: var(--muted-2); text-decoration: line-through; }
/*.done:before { content: "✓ "; } /* ☑ */
.in_progress { color: var(--in-progress); }
/*.in_progress:before { content: "⋯ "; }*/
.to-do,.to_do { color: var(--to-do); }
.reached { color: var(--reached); }

.uuid { color: var(--muted); }


/* Tableau des tâches */
.tasks-table {
    width: 100%;
    border-collapse: collapse;
}
.tasks-table thead th {
    font-weight: 600;
    padding: 0.4em 0.25em;
    border-bottom: 1px solid var(--border);
    background: var(--bg);
    text-align: left;
}
.tasks-table tbody td {
    padding: 0.35em 0.25em;
    border-bottom: 1px solid var(--border);
}
.tasks-table tbody tr {
    cursor: pointer;
}
.tasks-table tbody tr:hover {
    background: var(--hover-bg);
}
.tasks-table td a { color: var(--primary); text-decoration: none; }
.tasks-table td a:hover { text-decoration: underline; }


/* --- MODAL --- */

.modal-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: var(--overlay);
    z-index: 100;
    align-items: center;
    justify-content: center;
    padding: 1rem;
  }
  .modal-overlay.is-open { display: flex; }
  .modal {
    background: var(--card);
    border-radius: 10px;
    border: 1px solid var(--border);
    max-width: 520px;
    width: 100%;
    max-height: 90vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    box-shadow: var(--shadow-modal);
  }
  .modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1rem 1.25rem;
    border-bottom: 1px solid var(--border);
    background: var(--header-subtle);
  }
  .modal-header h2 { font-size: 1.1rem; font-weight: 600; margin: 0; font-family: "IBM Plex Mono", monospace; }
  .modal-close {
    font: inherit;
    width: 2rem;
    height: 2rem;
    border: none;
    background: transparent;
    cursor: pointer;
    border-radius: 6px;
    color: var(--muted);
    font-size: 1.25rem;
    line-height: 1;
    padding: 0;
  }
  .modal-close:hover { background: var(--hover-bg); color: var(--text); }
  .modal-body { padding: 1.25rem; overflow-y: auto; }

/* --- MAIN VIEW --- */

.main-header {
    margin-bottom: 2rem;
}

.main-header h1 {
    margin: 0 0 1rem 0;
    font-size: 1.75rem;
    color: var(--text);
}

.overview-container {
    margin-bottom: 1.5rem;
    padding: 1rem;
    background: var(--bg);
    border-radius: 8px;
    border: 1px solid var(--border);
}

.overview-container h2 {
    margin: 0 0 1rem 0;
    font-size: 1.1rem;
    font-weight: 600;
}

.phases-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 1rem;
}

.phase-card {
    padding: 1rem;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 6px;
    border-left: 4px solid var(--to-do);
}

.phase-card.phase-in_progress {
    border-left-color: var(--in-progress);
}

.phase-card.phase-done {
    border-left-color: var(--done);
}

.phase-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.75rem;
}

.phase-header h3 {
    margin: 0;
    font-size: 1rem;
    font-weight: 600;
}

.status-badge {
    padding: 0.25em 0.5em;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 500;
    text-transform: uppercase;
}

.status-badge.status-to_do {
    background: var(--badge-to-do-bg);
    color: var(--to-do);
}

.status-badge.status-in_progress {
    background: var(--badge-in-progress-bg);
    color: var(--in-progress);
}

.status-badge.status-done {
    background: var(--badge-done-bg);
    color: var(--done);
}

.phase-stats {
    display: flex;
    gap: 1rem;
    margin-bottom: 0.75rem;
    font-size: 0.875rem;
    color: var(--muted);
}

.milestones-list {
    margin-top: 0.5rem;
}

.milestone-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.375rem 0;
    font-size: 0.875rem;
    border-bottom: 1px solid var(--border);
}

.milestone-item:last-child {
    border-bottom: none;
}

.milestone-item.reached {
    color: var(--done);
}

.reached-badge {
    color: var(--done);
    font-weight: 600;
}

/* --- FILTERS --- */

.filters-wrapper {
    margin-bottom: 1.5rem;
    padding: 1rem;
    background: var(--bg);
    border-radius: 8px;
    border: 1px solid var(--border);
}

.filters-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 1rem;
    align-items: end;
}

.filter-group {
    display: flex;
    flex-direction: column;
}

.filter-group label {
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--text);
}

.filter-select {
    padding: 0.5rem;
    border: 1px solid var(--border);
    border-radius: 4px;
    background: var(--card);
    color: var(--text);
    font-size: 0.875rem;
    font-family: inherit;
    cursor: pointer;
}

.filter-select:hover {
    border-color: var(--primary);
}

.filter-select:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px var(--focus-ring);
}

.filter-reset {
    padding: 0.5rem 1rem;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text);
    font-size: 0.875rem;
    font-family: inherit;
    cursor: pointer;
    transition: all 0.2s;
}

.filter-reset:hover {
    background: var(--hover-bg);
    border-color: var(--muted);
}

/* --- PAGINATION --- */

.pagination-wrapper {
    margin-top: 1.5rem;
    padding: 1rem;
    background: var(--bg);
    border-radius: 8px;
    border: 1px solid var(--border);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 1rem;
}

.pagination-info {
    font-size: 0.875rem;
    color: var(--muted);
}

.pagination-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.pagination-btn,
.btn {
    padding: 0.5rem 0.75rem;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text);
    font-size: 0.875rem;
    font-family: inherit;
    cursor: pointer;
    transition: all 0.2s;
    text-decoration: none;
}
.btn.ghost {
    border-color: transparent;
}

.btn:hover:not(:disabled),
.pagination-btn:hover:not(:disabled) {
    background: var(--hover-bg);
    border-color: var(--primary);
}
.btn:disabled,
.pagination-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.pagination-page {
    padding: 0 0.75rem;
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--text);
}

/* --- TASKS CONTENT --- */

.tasks-content {
    margin-bottom: 1rem;
}

.tasks-content h2 {
    margin: 0 0 1rem 0;
    font-size: 1.25rem;
    font-weight: 600;
}

/* --- RESPONSIVE --- */

@media (max-width: 768px) {
    .box {
        margin: 0.5em;
        padding: 0.75em;
    }

    .filters-container {
        grid-template-columns: 1fr;
    }

    .phases-grid {
        grid-template-columns: 1fr;
    }

    .pagination-wrapper {
        flex-direction: column;
        align-items: stretch;
    }

    .pagination-controls {
        justify-content: center;
    }
})embed";
const char DOM_JS[] = R"embed(

/**
 * Utilitaire DOM : création d'éléments avec attributs et enfants
 *
 * @param {string} tag - Nom de l'élément HTML
 * @param {Object} attrs - Attributs (clé/valeur), null/undefined ignorés
 * @param {...(string|Node)} children - Enfants (texte ou nœuds DOM)
 * @returns {HTMLElement}
 */
export function el(tag, attrs, ...children) {
    const elem = document.createElement(tag);
    for (const [key, value] of Object.entries(attrs || {})) {
        if (value != null) elem.setAttribute(key, value);
    }
    for (const child of children) {
        if (typeof child === 'string') {
            elem.appendChild(document.createTextNode(child));
        } else if (child != null) {
            elem.appendChild(child);
        }
    }
    return elem;
}
)embed";
const char FILTERS_JS[] = R"embed(

/**
 * Gestion des filtres pour les tâches (milestone, phase, role, status)
 */
const allOpt = '— All —' ;
export class Filters {
    constructor() {
        this.filters = {
            milestone: '',
            phase: '',
            role: '',
            status: ''
        };
        this.onChangeCallback = null;
    }

    /**
     * Définit un callback appelé quand les filtres changent
     */
    setOnChange(callback) {
        this.onChangeCallback = callback;
    }

    /**
     * Met à jour un filtre
     */
    setFilter(name, value) {
        if (this.filters.hasOwnProperty(name)) {
            this.filters[name] = value || '';
            if (this.onChangeCallback) {
                this.onChangeCallback(this.filters);
            }
        }
    }

    /**
     * Récupère tous les filtres
     */
    getFilters() {
        return { ...this.filters };
    }

    /**
     * Construit les paramètres de requête à partir des filtres
     */
    buildQueryParams() {
        const params = new URLSearchParams();
        for (const [key, value] of Object.entries(this.filters)) {
            if (value) {
                params.append(key, value);
            }
        }
        return params;
    }

    /**
     * Crée l'interface utilisateur des filtres
     */
    render(container) {
        const filtersDiv = document.createElement('div');
        filtersDiv.className = 'filters-container';

        // Filtre Phase
        const phaseGroup = this.createSelectGroup('phase', 'Phase', []);
        filtersDiv.appendChild(phaseGroup);

        // Filtre Milestone
        const milestoneGroup = this.createSelectGroup('milestone', 'Milestone', []);
        filtersDiv.appendChild(milestoneGroup);

        // Filtre Role
        const roleGroup = this.createSelectGroup('role', 'Rôle', [
            { value: '', label:allOpt },
            { value: 'project-manager', label: 'Project Manager' },
            { value: 'project-designer', label: 'Project Designer' },
            { value: 'software-architect', label: 'Software Architect' },
            { value: 'developer', label: 'Developer' },
            { value: 'summary-writer', label: 'Summary Writer' },
            { value: 'documentation-writer', label: 'Documentation Writer' }
        ]);
        filtersDiv.appendChild(roleGroup);

        // Filtre Status
        const statusGroup = this.createSelectGroup('status', 'Statut', [
            { value: '', label: allOpt },
            { value: 'to_do', label: 'À faire' },
            { value: 'in_progress', label: 'En cours' },
            { value: 'done', label: 'Terminé' }
        ]);
        filtersDiv.appendChild(statusGroup);

        // Bouton réinitialiser
        /* // Temporary disabled: reset button is not used anymore
        const resetBtn = document.createElement('button');
        resetBtn.className = 'filter-reset';
        resetBtn.textContent = 'Réinitialiser';
        resetBtn.addEventListener('click', () => {
            this.filters = { milestone: '', phase: '', role: '', status: '' };
            filtersDiv.querySelectorAll('select').forEach(select => {
                select.value = '';
            });
            if (this.onChangeCallback) {
                this.onChangeCallback(this.filters);
            }
        });
        filtersDiv.appendChild(resetBtn);
        */

        container.appendChild(filtersDiv);
        return filtersDiv;
    }

    /**
     * Crée un groupe de sélection (label + select)
     */
    createSelectGroup(name, label, options) {
        const group = document.createElement('div');
        group.className = 'filter-group';

        const labelEl = document.createElement('label');
        labelEl.textContent = label;
        labelEl.setAttribute('for', `filter-${name}`);
        group.appendChild(labelEl);

        const select = document.createElement('select');
        select.id = `filter-${name}`;
        select.className = 'filter-select';

        // Options par défaut si non fournies
        if (options.length === 0) {
            options.push({ value: '', label: allOpt });
        }

        options.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt.value;
            option.textContent = opt.label;
            if (this.filters[name] === opt.value) {
                option.selected = true;
            }
            select.appendChild(option);
        });

        select.addEventListener('change', (e) => {
            this.setFilter(name, e.target.value);
        });

        group.appendChild(select);
        return group;
    }

    /**
     * Met à jour les options d'un select (pour phases et milestones dynamiques)
     */
    updateSelectOptions(name, options) {
        const select = document.getElementById(`filter-${name}`);
        if (!select) return;

        const currentValue = select.value;
        select.innerHTML = '';
        
        const defaultOpt = document.createElement('option');
        defaultOpt.value = '';
        defaultOpt.textContent = allOpt;
        select.appendChild(defaultOpt);

        options.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt.value;
            option.textContent = opt.label;
            select.appendChild(option);
        });

        // Restaurer la valeur si elle existe toujours
        if (currentValue && options.some(opt => opt.value === currentValue)) {
            select.value = currentValue;
        } else {
            select.value = '';
            this.setFilter(name, '');
        }
    }
}
)embed";
const char PAGINATION_JS[] = R"embed(

/**
 * Gestion de la pagination pour les tâches
 */

import { el } from './dom.js';

export class Pagination {
    constructor() {
        this.currentPage = 1;
        this.pageSize = 50;
        this.totalCount = 0;
        this.onPageChangeCallback = null;
    }

    /**
     * Définit un callback appelé quand la page change
     */
    setOnPageChange(callback) {
        this.onPageChangeCallback = callback;
    }

    /**
     * Définit la taille de page
     */
    setPageSize(size) {
        this.pageSize = Math.max(1, size);
        this.currentPage = 1; // Reset à la première page
    }

    /**
     * Définit le nombre total d'éléments
     */
    setTotalCount(count) {
        this.totalCount = Math.max(0, count);
        // Ajuster la page courante si nécessaire
        const maxPage = this.getTotalPages();
        if (this.currentPage > maxPage && maxPage > 0) {
            this.currentPage = maxPage;
        }
    }

    /**
     * Va à une page spécifique
     */
    goToPage(page) {
        const maxPage = this.getTotalPages();
        const newPage = Math.max(1, Math.min(page, maxPage));
        if (newPage !== this.currentPage) {
            this.currentPage = newPage;
            if (this.onPageChangeCallback) {
                this.onPageChangeCallback(this.currentPage);
            }
        }
    }

    /**
     * Page suivante
     */
    nextPage() {
        this.goToPage(this.currentPage + 1);
    }

    /**
     * Page précédente
     */
    previousPage() {
        this.goToPage(this.currentPage - 1);
    }

    /**
     * Calcule le nombre total de pages
     */
    getTotalPages() {
        return Math.max(1, Math.ceil(this.totalCount / this.pageSize));
    }

    /**
     * Récupère la page courante
     */
    getCurrentPage() {
        return this.currentPage;
    }

    /**
     * Récupère la taille de page
     */
    getPageSize() {
        return this.pageSize;
    }

    /**
     * Récupère l'offset pour la requête SQL
     */
    getOffset() {
        return (this.currentPage - 1) * this.pageSize;
    }

    /**
     * Récupère les informations de pagination pour l'affichage
     */
    getInfo() {
        const start = this.totalCount === 0 ? 0 : (this.currentPage - 1) * this.pageSize + 1;
        const end = Math.min(this.currentPage * this.pageSize, this.totalCount);
        return {
            start,
            end,
            total: this.totalCount,
            currentPage: this.currentPage,
            totalPages: this.getTotalPages()
        };
    }

    /**
     * Crée l'interface utilisateur de pagination
     */
    render(container) {
        const info = this.getInfo();
        const infoSpan = el('span', { class: 'pagination-info' });
        const pageSpan = el('span', { class: 'pagination-page' }, `${this.currentPage} / ${info.totalPages}`);

        const firstBtn = el('button', { class: 'pagination-btn' }, '«');
        firstBtn.disabled = this.currentPage === 1;
        firstBtn.addEventListener('click', () => this.goToPage(1));

        const prevBtn = el('button', { class: 'pagination-btn' }, '‹');
        prevBtn.disabled = this.currentPage === 1;
        prevBtn.addEventListener('click', () => this.previousPage());

        const nextBtn = el('button', { class: 'pagination-btn' }, '›');
        nextBtn.disabled = this.currentPage >= info.totalPages;
        nextBtn.addEventListener('click', () => this.nextPage());

        const lastBtn = el('button', { class: 'pagination-btn' }, '»');
        lastBtn.disabled = this.currentPage >= info.totalPages;
        lastBtn.addEventListener('click', () => this.goToPage(info.totalPages));

        const controlsDiv = el('div', { class: 'pagination-controls' },
            firstBtn, prevBtn, pageSpan, infoSpan, nextBtn, lastBtn
        );
        const paginationDiv = el('div', { class: 'pagination-container' }, controlsDiv);

        // Fonction pour mettre à jour l'affichage
        const updateDisplay = () => {
            const newInfo = this.getInfo();
            infoSpan.textContent = `(${newInfo.start}-${newInfo.end} / ${newInfo.total})`;
            pageSpan.textContent = `${newInfo.currentPage} / ${newInfo.totalPages}`;
            firstBtn.disabled = newInfo.currentPage === 1;
            prevBtn.disabled = newInfo.currentPage === 1;
            nextBtn.disabled = newInfo.currentPage >= newInfo.totalPages;
            lastBtn.disabled = newInfo.currentPage >= newInfo.totalPages;
        };

        paginationDiv.updateDisplay = updateDisplay;
        updateDisplay();

        container.appendChild(paginationDiv);
        return paginationDiv;
    }
}
)embed";
const char MAIN_JS[] = R"embed(
import { el } from './dom.js';
import { Filters } from './filters.js';
import { Pagination } from './pagination.js';

const app = document.getElementById('app');

// État global
let filters = new Filters();
let pagination = new Pagination();
/** @type {Record<string, { id: string, name?: string, [k: string]: unknown }>} phases indexés par id */
let phases = {};
/** @type {Record<string, { id: string, name?: string, [k: string]: unknown }>} milestones indexés par id */
let milestones = {};
let tasks = [];
let taskDeps = [];

/**
 * Initialisation de l'application
 */
async function init() {
    // Charger les phases et milestones pour les filtres
    await loadPhasesAndMilestones();
    
    // Configurer les callbacks
    filters.setOnChange(() => {
        pagination.goToPage(1);
        loadTasks();
    });
    
    pagination.setOnPageChange(() => {
        loadTasks();
    });

    // Afficher la vue principale
    renderMainView();
    await loadTasks();
}

/**
 * Charge les phases et milestones pour les filtres
 */
async function loadPhasesAndMilestones() {
    try {
        const [phasesRes, milestonesRes] = await Promise.all([
            fetch('/phases?limit=100'),
            fetch('/milestones?limit=100')
        ]);
        
        if (phasesRes.ok) {
            const arr = await phasesRes.json();
            phases = Object.fromEntries((Array.isArray(arr) ? arr : []).map((p) => [p.id, p]));
        }
        
        if (milestonesRes.ok) {
            const arr = await milestonesRes.json();
            milestones = Object.fromEntries((Array.isArray(arr) ? arr : []).map((m) => [m.id, m]));
        }
    } catch (e) {
        console.error('Error loading phases/milestones:', e);
    }
}

/**
 * Affiche la vue principale avec filtres et pagination
 */
function renderMainView() {
    const ALL = ''
    app.innerHTML = '';
    
    // En-tête avec vue d'ensemble
    // const header = el('div', { class: 'main-header' }, el('h1', {}, 'Gestionnaire de Projet'));
    const header = el('div', {});
    
    // Vue d'ensemble des phases
    /*
    const overviewDiv = document.createElement('div');
    overviewDiv.className = 'overview-container';
    overviewDiv.appendChild(el('h2', {}, 'Vue d\'ensemble'));
    const overviewContent = document.createElement('div');
    overviewContent.className = 'overview-content';
    overviewDiv.appendChild(overviewContent);
    header.appendChild(overviewDiv);
    */
    app.appendChild(header);
    
    // Filtres
    const filtersContainer = document.createElement('div');
    filtersContainer.className = 'filters-wrapper';
    filters.render(filtersContainer);
    app.appendChild(filtersContainer);
    
    // Mettre à jour les options des selects dynamiques
    const phaseOptions = [].concat(
        Object.values(phases).map(p => ({ value: p.id, label: `${p.id}: ${p.name || p.id}` }))
    );
    filters.updateSelectOptions('phase', phaseOptions);
    
    const milestoneOptions = [].concat(
        Object.values(milestones).map(m => ({ value: m.id, label: `${m.id}: ${m.name || m.id}` }))
    );
    filters.updateSelectOptions('milestone', milestoneOptions);
    
    // Zone de contenu pour les tâches
    const contentDiv = el('div', { class: 'tasks-content' }, 'tasks-content');
    contentDiv.className = 'tasks-content';
    contentDiv.id = 'tasks-content';
    app.appendChild(contentDiv);
    
    // Pagination
    const paginationContainer = document.createElement('div');
    paginationContainer.className = 'pagination-wrapper';
    paginationContainer.id = 'pagination-container';
    app.appendChild(paginationContainer);
    
    // Charger la vue d'ensemble
    // updateOverview(overviewContent);
}

/**
 * Met à jour la vue d'ensemble des phases
 */
async function updateOverview(container) {
    container.innerHTML = '';

    // Temporary disabled: overview is not used anymore
    return;
    
    if (Object.keys(phases).length === 0) {
        container.appendChild(el('p', { class: 'muted' }, 'Aucune phase.'));
        return;
    }
    
    const phasesGrid = document.createElement('div');
    phasesGrid.className = 'phases-grid';
    
    for (const phase of Object.values(phases)) {
        const phaseCard = document.createElement('div');
        phaseCard.className = `phase-card phase-${phase.status || 'to_do'}`;
        
        const phaseHeader = document.createElement('div');
        phaseHeader.className = 'phase-header';
        phaseHeader.appendChild(el('h3', {}, escapeHtml(phase.name || phase.id)));
        phaseHeader.appendChild(el('span', { class: `status-badge status-${phase.status || 'to_do'}` }, phase.status || 'to_do'));
        phaseCard.appendChild(phaseHeader);
        
        // Compter les milestones et tâches pour cette phase
        const phaseMilestones = Object.values(milestones).filter(m => m.phase_id === phase.id);
        const phaseTasks = tasks.filter(t => t.phase_id === phase.id);
        const doneTasks = phaseTasks.filter(t => t.status === 'done').length;
        
        const stats = document.createElement('div');
        stats.className = 'phase-stats';
        stats.appendChild(el('div', {}, `Milestones: ${phaseMilestones.length}`));
        stats.appendChild(el('div', {}, `Tâches: ${doneTasks}/${phaseTasks.length}`));
        phaseCard.appendChild(stats);
        
        // Afficher les milestones
        if (phaseMilestones.length > 0) {
            const milestonesList = document.createElement('div');
            milestonesList.className = 'milestones-list';
            phaseMilestones.forEach(m => {
                const milestoneEl = document.createElement('div');
                milestoneEl.className = `milestone-item ${m.reached ? 'reached' : ''}`;
                milestoneEl.appendChild(el('span', {}, escapeHtml(m.name || m.id)));
                if (m.reached) {
                    milestoneEl.appendChild(el('span', { class: 'reached-badge' }, '✓'));
                }
                milestonesList.appendChild(milestoneEl);
            });
            phaseCard.appendChild(milestonesList);
        }
        
        phasesGrid.appendChild(phaseCard);
    }
    
    container.appendChild(phasesGrid);
}

/**
 * Charge les tâches avec filtres et pagination
 */
async function loadTasks() {
    const contentDiv = document.getElementById('tasks-content');
    if (!contentDiv) return;
    
    contentDiv.innerHTML = '<p>Chargement...</p>';
    
    try {
        const filterParams = filters.buildQueryParams();
        filterParams.append('limit', pagination.getPageSize());
        filterParams.append('page', pagination.getCurrentPage());
        
        // Charger le nombre total et les tâches
        const countParams = filters.buildQueryParams();
        const [countRes, tasksRes, depsRes] = await Promise.all([
            fetch(`/tasks/count?${countParams}`),
            fetch(`/tasks?${filterParams}`),
            fetch(`/task_deps?limit=500`)
        ]);
        
        if (!tasksRes.ok) {
            contentDiv.innerHTML = `<p class="error">Erreur ${tasksRes.status}</p>`;
            return;
        }
        
        // Mettre à jour le nombre total
        if (countRes.ok) {
            const countData = await countRes.json();
            pagination.setTotalCount(countData.count || 0);
        }
        
        tasks = await tasksRes.json();
        
        // Charger les dépendances
        if (depsRes.ok) {
            taskDeps = await depsRes.json();
        } else {
            taskDeps = [];
        }
        
        // Mettre à jour la pagination
        const paginationContainer = document.getElementById('pagination-container');
        if (paginationContainer) {
            paginationContainer.innerHTML = '';
            const paginationEl = pagination.render(paginationContainer);
            // Mettre à jour l'affichage de la pagination
            if (paginationEl.updateDisplay) {
                paginationEl.updateDisplay();
            }
        }
        
        // Afficher les tâches
        if (!Array.isArray(tasks) || tasks.length === 0) {
            contentDiv.innerHTML = '<p class="muted">Aucune tâche trouvée.</p>';
            return;
        }
        
        // Charger les statuts des dépendances manquantes
        const idToStatus = new Map(tasks.map(t => [t.id, t.status]));
        const taskIds = new Set(idToStatus.keys());
        const depsForOurTasks = taskDeps.filter(d => taskIds.has(d.task_id));
        const missingDepIds = [...new Set(depsForOurTasks.map(d => d.depends_on).filter(id => !idToStatus.has(id)))];
        
        await Promise.all(missingDepIds.map(async (id) => {
            try {
                const r = await fetch(`/task/${id}`);
                if (r.ok) {
                    const j = await r.json();
                    idToStatus.set(id, j.status);
                }
            } catch (_) {}
        }));
        
        const isBlocked = (t) => {
            const taskDeps = depsForOurTasks.filter(d => d.task_id === t.id);
            return taskDeps.some(d => (idToStatus.get(d.depends_on) || '') !== 'done');
        };
        
        const table = createTaskListTable(tasks, {
            onTaskClick: (t) => loadTask(t.id),
            getStatusSuffix: (t) => isBlocked(t)
        });
        
        contentDiv.innerHTML = '';
        contentDiv.appendChild(el('h2', {}, 'Tâches'));
        contentDiv.appendChild(table);
        
        // Mettre à jour la vue d'ensemble
        const overviewContent = document.querySelector('.overview-content');
        if (overviewContent) {
            updateOverview(overviewContent);
        }
        
    } catch (e) {
        contentDiv.innerHTML = `<p class="error">${e.message}</p>`;
    }
}

function getMilestoneName(id) {
    const milestone = milestones[id] || null;
    if (!milestone) { return '—';}
    return milestone.id + (milestone.name ? " - " + milestone.name : '');
}
function getPhaseName(id) {
    const phase = phases[id] || null;
    if (!phase) { return '—';}
    return phase.id + (phase.name ? " - " + phase.name : '');
}

/**
 * Charge les détails d'une tâche
 */
async function loadTask(id) {
    app.innerHTML = '';
    try {
        const [taskRes, depsRes, allDepsRes, notesRes] = await Promise.all([
            fetch(`/task/${id}`),
            fetch(`/task/${id}/deps`),
            fetch(`/task_deps?limit=500`),
            fetch(`/task/${id}/notes`)
        ]);
        if (!taskRes.ok) {
            app.innerHTML = taskRes.status === 404 ? '<p class="error">Tâche introuvable.</p>' : `<p class="error">Erreur ${taskRes.status}</p>`;
            return;
        }
        const t = await taskRes.json();

        let deps = [];
        try { if (depsRes.ok) deps = await depsRes.json(); } catch (_) {}
        deps = Array.isArray(deps) ? deps : [];
        const parentIds = deps.map((d) => d.depends_on).filter(Boolean);

        let allDeps = [];
        try { if (allDepsRes.ok) allDeps = await allDepsRes.json(); } catch (_) {}
        allDeps = Array.isArray(allDeps) ? allDeps : [];
        const childIds = allDeps.filter((d) => d.depends_on === id).map((d) => d.task_id);

        let taskNotes = [];
        try { if (notesRes.ok) taskNotes = await notesRes.json(); } catch (_) {}
        taskNotes = Array.isArray(taskNotes) ? taskNotes : [];

        const parentTasks = [];
        const childTasks = [];
        await Promise.all([
            ...parentIds.map(async (pid) => {
                try {
                    const r = await fetch(`/task/${pid}`);
                    if (r.ok) parentTasks.push(await r.json());
                } catch (_) {}
            }),
            ...childIds.map(async (cid) => {
                try {
                    const r = await fetch(`/task/${cid}`);
                    if (r.ok) childTasks.push(await r.json());
                } catch (_) {}
            })
        ]);

        const div = document.createElement('div');
        div.className = 'task-detail';

        const back = el('p', {}, el('a', { href: '#', id: 'back' , class: 'btn ghost'}, '← Back'));
        back.querySelector('#back').addEventListener('click', (e) => { e.preventDefault(); init(); });
        div.appendChild(back);

        const head = el('div', {class:"", style:"max-width:40em;margin:3rem;font-size:125%"},
            el('h2', {}, escapeHtml(t.title || 'Sans titre')),
            el('p', { class: 'task-description' }, escapeHtml(t.description))
        );
        div.appendChild(head);

        const isBlocked = parentTasks.length > 0 && parentTasks.some((p) => p && p.status !== 'done');
        const meta = document.createElement('table');
        meta.className = 'task-meta';
        const phaseLabel = getPhaseName(t.phase_id);
        const milestoneLabel = getMilestoneName(t.milestone_id);
        const rows = [
            // ['Subject', escapeHtml(t.title || 'Sans titre'), 'row-title'],
            // ['Description', escapeHtml(t.description || 'Everything is in the title.'), 'row-description'],
            ['ID', String(t.id || '—'), 'uuid monospace'],
            ['Statut', null, ''],
            ['Rôle', String(t.role || '— THIS TASK IS NOT ASSIGNED —'), (t.role || '' ) ? '' : 'error'],
            ['Phase', String(phaseLabel), ''],
            ['Jalon', String(milestoneLabel), ''],
            ['Ordre', t.sort_order != null ? String(t.sort_order) : '—', ''],
            ['Créé le', t.created_at != null ? String(t.created_at) : '—', ''],
            ['Mis à jour le', t.updated_at != null ? String(t.updated_at) : '—', '']
        ];
        for (const [label, val, className] of rows) {
            const labelTd = el('td', { class: 'task-meta-label' }, label);
            let valueTd;
            if (label === 'Statut') {
                valueTd = el('td', {}, t.status || '—');
                if (isBlocked) valueTd.appendChild(el('span', { class: 'blocked' }, ' (blocked)'));
            }
            // else if (label === 'Subject') {
            //     valueTd = el('td', {}, el('div',{style:'width:40em;font-size:150%'},val));
            // }
            // else if (label === 'Description') {
            //     valueTd = el('td', {}, el('div',{style:''},val));
            // }
            else {
                valueTd = el('td', {class:className}, escapeHtml(val));
            }
            meta.appendChild(el('tr', {}, labelTd, valueTd));
        }


        div.appendChild(el('div', {class: 'card'}, meta));

        div.appendChild(el('h3', {style:"margin:2rem 0 0;"}, 'Historique des notes'));
        if (taskNotes.length === 0) {
            div.appendChild(el('p', { class: 'muted' }, 'Aucune note pour cette tâche.'));
        } else {
            const notesList = document.createElement('div');
            notesList.className = 'task-notes-history';
            for (const n of taskNotes) {
                const noteCard = document.createElement('div');
                noteCard.className = 'task-note-card';
                const metaLine = [];
                if (n.kind) metaLine.push(escapeHtml(n.kind));
                if (n.role) metaLine.push(escapeHtml(n.role));
                if (n.created_at) metaLine.push(escapeHtml(n.created_at));
                const metaStr = metaLine.length ? metaLine.join(' · ') : '';
                noteCard.appendChild(el('div', { class: 'task-note-meta muted' }, metaStr));
                noteCard.appendChild(el('div', { class: 'task-note-content' }, escapeHtml(n.content || '')));
                notesList.appendChild(noteCard);
            }
            div.appendChild(notesList);
        }

        div.appendChild(el('h3', {style:"margin:2rem 0 0;"}, 'Tâches parentes (dont dépend cette tâche)'));
        if (parentTasks.length === 0) {
            div.appendChild(el('p', { class: 'muted' }, 'Aucune tâche.'));
        } else {
            div.appendChild(createTaskListTable(parentTasks, { onTaskClick: (task) =>)embed"
    R"embed( loadTask(task.id) }));
        }

        div.appendChild(el('h3', {style:"margin:2rem 0 0;"}, 'Tâches enfants (qui dépendent de cette tâche)'));
        if (childTasks.length === 0) {
            div.appendChild(el('p', { class: 'muted' }, 'Aucune tâche.'));
        } else {
            div.appendChild(createTaskListTable(childTasks, { onTaskClick: (task) => loadTask(task.id) }));
        }

        app.appendChild(div);
    } catch (e) {
        app.innerHTML = `<p class="error">${e.message}</p>`;
    }
}

let escapeHTMLElement = null;
function escapeHtml(s) {
    if (escapeHTMLElement === null) {
        escapeHTMLElement = document.createElement('div');
    }
    escapeHTMLElement.textContent = s;
    return escapeHTMLElement.innerHTML;
}

/**
 * Reusabel task list
 */
function createTaskListTable(tasks, { onTaskClick, getStatusSuffix = () => false }) {
    const table = document.createElement('table');
    table.className = 'tasks-table';
    const thead = document.createElement('thead');
    thead.appendChild(el('tr', {}, ...['id', 'title', 'role', 'status', 'milestone', 'phase', 'changed'].map((h) => {
        const th = document.createElement('th');
        th.textContent = h;
        return th;
    })));
    table.appendChild(thead);
    const tbody = document.createElement('tbody');
    for (const t of tasks) {
        const suffix = getStatusSuffix(t);

        let label = t.status || '';
        if (label === 'to_do' && suffix) {
            label = 'blocked';
        }

        let updated = new Date(t.updated_at).toLocaleString();
        if (updated === 'Invalid Date') updated = '';
        let timeAgo = new Date(t.updated_at).getTime() - new Date().getTime();
        if (timeAgo < 0) timeAgo = 0;
        timeAgo = Math.floor(timeAgo / 1000 / 3600 / 24);
        timeAgo = `${timeAgo} day${timeAgo !== 1 ? 's' : ''} ago`;
        

        const milestoneName = (milestones[t.milestone_id]?.name ?? t.milestone_id ?? '');
        const phaseName = (phases[t.phase_id]?.name ?? t.phase_id ?? '');
        const tr = el('tr', { 'data-task-id': t.id , class: label },
            el('td', { class: 'monospace uuid' }, escapeHtml(String(t.id ?? '').substring(0, 8))),
            el('td', {}, el('a', { href: '#' }, escapeHtml(t.title || t.id || 'untitled'))),
            el('td', {}, escapeHtml(t.role || '')),
            el('td', {},
                el('span', { class: label }, label)
            ),
            el('td', {}, escapeHtml(milestoneName)),
            el('td', {}, escapeHtml(phaseName)),
            el('td', {class: 'muted'}, escapeHtml(timeAgo))
        );
        tr.addEventListener('click', (e) => { e.preventDefault(); onTaskClick(t); });
        tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    return table;
}

// Démarrer l'application
init();
)embed";

} // namespace
